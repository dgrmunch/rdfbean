<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="getting-started" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Getting started with RDFBean</title>
    
    <para>The core of RDFBean usage is the usage of RDFBean annotated domain types.</para>
    
    <sect1>
    
      <title>RDFBean annotations</title>
      
      <sect2>
      
      <title>ClassMapping</title>
      
      <para><emphasis>ClassMapping</emphasis> declares a mapping from a Java type to an RDF type. If your Java type 
      simple name
      is equal to the local name of the RDF type, which is a good practice, all you need to do is to declare 
      the namespace. The namespace is best kept accessible via a public static final String constant : </para>
      
<programlisting language="java"><![CDATA[    
@ClassMapping(ns=TEST.NS)
public class User {

    // ...
}
]]></programlisting>        

    </sect2>
      
    <sect2>
    
      <title>Predicate</title>  
      
      <para><emphasis>Predicate</emphasis> declares a mapping from a Java property to an RDF predicate / property. 
        You can annotate getters and fields with it. </para>
        
      <para>A good practice is to not repeat the namespace declaration for a Predicate annotation, if the predicate 
      namespace is the same as the namespace of the host type : </para>
      
<programlisting language="java"><![CDATA[    
@ClassMapping(ns=TEST.NS)
public class User {

    @Predicate(ln="user_name")
    private String userName;
    
    @Predicate
    private String email;
}
]]></programlisting>          

    <para>The default value for the local name is the property's name.</para>
    
    <para>A Predicate can be forward and inverse mapped. Forward is the default and inverse can be declared, by setting
    the annotation's inv attribute to true. Inverse means that the host entity is not in the subject position for
    the bound triples, but in the object position and the bound values correspond to the subjects of the triples.</para>
    
    <para>Inverse Predicates cannot be declared on literal properties.</para>
    
    </sect2>
    
    <sect2>
    
    <title>Id</title>
    
    <para><emphasis>Id</emphasis> is used to annotate properties holding the id of the entity. The default is to handle 
    the id as an RDFBean managed integer surrogate id. Numeric ids are shorter than full URLs or bnode ids and are easier
    to use on the application level :</para>
    
<programlisting language="java"><![CDATA[    
@ClassMapping(ns=TEST.NS)
public class User {

    @Id
    private String id;

    @Predicate(ln="user_name")
    private String userName;
    
    @Predicate
    private String email;
}
]]></programlisting>          
    
    <para>Alternatively the id can be injected in IDType.URI or IDType.RESOURCE form. Use the UID or ID type for URI 
    injection
    and ID for RESOURCE typed injection.</para>
    
    </sect2>
    
    <sect2>
    
    <title>MappedClasses</title>
    
    <para>A good practice is to use <emphasis>MappedClasses</emphasis> in the domain package package-info.java to 
    declare the annotated types in the package.</para>
    
    <para>This way you can use <emphasis>DefaultConfiguration.addPackages</emphasis> to configure the annoteated
     types. </para>
    
<programlisting language="java"><![CDATA[      
@MappedClasses( { 
    Document.class, 
    Folder.class,
    Identifiable.class,
    Location.class,
    Person.class,
    User.class,
    UserInfo.class})
package com.myproject.domain;

import com.mysema.rdfbean.annotations.MappedClasses;
    
]]></programlisting>   
    
    </sect2>
    
    <sect2>
         
    <title>Localized</title>
     
    <para><emphasis>Localized</emphasis> defines that a property is bound to a localized value. The locale preference
    is set in the Session. When multiple values with different locales are available for a property, the value with
    the best matching locale is bound to the Java property. 
    </para>
    
    <para>For updates the the primary locale is used as the literal's locale.</para>
    
    </sect2>
    
    <sect2>

      <title>Mixin</title>
    
      <para><emphasis>Mixin</emphasis> defines a view on the host type's subject with a different type.
        Mixin can't be combined with Predicate or Path, since the RDF identity of the mixin property is the 
        same as the host's identity.</para>    
    
    </sect2>
    
    <sect2>
    
      <title>Context</title>
      
      <para><emphasis>Context</emphasis> defines the target context of the annotated type or
      the context of the types of an annotated package.</para>
    
    </sect2>
    
    <sect2>
    
      <title>Path</title>
    
      <para><emphasis>Path</emphasis> defines a chain of predicates for readonly properties. The value accessible
      by the predicate path is bound to the property. Path can contain both direct and inverse predicates. </para>
    
    </sect2>
    
    <sect2>
    
      <title>Required</title>
    
      <para><emphasis>Required</emphasis> defines that a certain property is mandatory.</para>
      
<programlisting language="java"><![CDATA[    
@ClassMapping(ns=TEST.NS)
public class User {

    @Id
    private String id;

    @Predicate
    @Required
    private String email;
    
}
]]></programlisting>       
          
    
    </sect2>
    
    <sect2>
    
      <title>Unique</title>
    
      <para><emphasis>Unique</emphasis> defines that the annotated property is unique.</para>
      
<programlisting language="java"><![CDATA[    
@ClassMapping(ns=TEST.NS)
public class User {

    @Id
    private String id;

    @Predicate(ln="user_name")
    @Unique
    private String userName;
    
}
]]></programlisting>       
    
    </sect2>
    
    </sect1>
    
    <sect1>
    
      <title>Basic RDF persistence</title>
      
      <para>TODO</para>
    
    </sect1>
    
    <sect1>
    
      <title>Type-safe querying</title>      
      
  <sect2>
      
  <title>General usage</title>
  
  <para>Use the the cascading methods of the HQLQuery method like this</para>
  
  <para><emphasis>from :</emphasis> Define the query sources here.</para>
  
  <para><emphasis>where :</emphasis> Define the query filters, either in varargs form separated via commas or 
  cascaded via the and-operator.</para>
  
  <para><emphasis>orderBy :</emphasis> Define the ordering of the result as an varargs array of order expressions. 
  Use asc() and desc() on numeric, string and other comparable expression to access the OrderSpecifier instances. </para>
  
  <para><emphasis>limit, offset, restrict :</emphasis> Define the paging of the result. Limit for max results, 
  offset for skipping rows and restrict for defining both in one call.</para>
  
  </sect2>  
  
  <sect2>
  
  <title>Ordering</title>
  
  <para>The syntax for declaring ordering is </para>
  
<programlisting language="java"><![CDATA[ 
query.from(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.desc())
    .list(customer);
]]></programlisting>

  </sect2>  
      
    </sect1>
    
</chapter>    