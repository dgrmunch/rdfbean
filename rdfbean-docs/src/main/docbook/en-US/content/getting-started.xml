<!DOCTYPE chapter PUBLIC "-//OASIS//DTD DocBook XML V4.5//EN" "http://www.oasis-open.org/docbook/xml/4.5/docbookx.dtd">

<chapter id="getting-started" xmlns:xi="http://www.w3.org/2001/XInclude">
    <title>Getting started with RDFBean</title>
    
    <para>The core of RDFBean usage is the usage of RDFBean annotated domain types.</para>
    
    <sect1>
    
      <title>RDFBean annotations</title>
      
      <sect2>
      
      <title>ClassMapping</title>
      
      <para><emphasis>ClassMapping</emphasis> declares a mapping from a Java type to an RDF type. If your Java type 
      simple name
      is equal to the local name of the RDF type, which is a good practice, all you need to do is to declare 
      the namespace. The namespace is best kept accessible via a public static final String constant : </para>
      
<programlisting language="java"><![CDATA[    
@ClassMapping(ns=TEST.NS)
public class User {

    // ...
}
]]></programlisting>        

    </sect2>
      
    <sect2>
    
      <title>Predicate</title>  
      
      <para><emphasis>Predicate</emphasis> declares a mapping from a Java property to an RDF predicate / property. 
        You can annotate getters and fields with it. </para>
        
      <para>A good practice is to not repeat the namespace declaration for a Predicate annotation, if the predicate 
      namespace is the same as the namespace of the host type : </para>
      
<programlisting language="java"><![CDATA[    
@ClassMapping(ns=TEST.NS)
public class User {

    @Predicate(ln="user_name")
    private String userName;
    
    @Predicate
    private String email;
}
]]></programlisting>          

    <para>The default value for the local name is the property's name.</para>
    
    <para>A Predicate can be forward and inverse mapped. Forward is the default and inverse can be declared, by setting
    the annotation's inv attribute to true. Inverse means that the host entity is not in the subject position for
    the bound triples, but in the object position and the bound values correspond to the subjects of the triples.</para>
    
    <para>Inverse Predicates cannot be declared on literal properties.</para>
    
    </sect2>
    
    <sect2>
    
    <title>Id</title>
    
    <para><emphasis>Id</emphasis> is used to annotate properties holding the id of the entity. The default is to handle 
    the id as an RDFBean managed integer surrogate id. Numeric ids are shorter than full URLs or bnode ids and are easier
    to use on the application level :</para>
    
<programlisting language="java"><![CDATA[    
@ClassMapping(ns=TEST.NS)
public class User {

    @Id
    private String id;

    @Predicate(ln="user_name")
    private String userName;
    
    @Predicate
    private String email;
}
]]></programlisting>          
    
    <para>Alternatively the id can be injected in IDType.URI or IDType.RESOURCE form. Use the UID or ID type for URI 
    injection
    and ID for RESOURCE typed injection.</para>
    
    </sect2>
    
    <sect2>
    
    <title>MappedClasses</title>
    
    <para>A good practice is to use <emphasis>MappedClasses</emphasis> in the domain package package-info.java to 
    declare the annotated types in the package.</para>
    
    <para>This way you can use <emphasis>DefaultConfiguration.addPackages</emphasis> to configure the annotated
     types. </para>
    
<programlisting language="java"><![CDATA[      
@MappedClasses( { 
    Document.class, 
    Folder.class,
    Identifiable.class,
    Location.class,
    Person.class,
    User.class,
    UserInfo.class})
package com.myproject.domain;

import com.mysema.rdfbean.annotations.MappedClasses;
    
]]></programlisting>   
    
    </sect2>
    
    <sect2>
         
    <title>Localized</title>
     
    <para><emphasis>Localized</emphasis> defines that a property is bound to a localized value. The locale preference
    is set in the Session. When multiple values with different locales are available for a property, the value with
    the best matching locale is bound to the Java property. 
    </para>
    
    <para>For updates the the primary locale is used as the literal's locale.</para>
    
    </sect2>
    
    <sect2>

      <title>Mixin</title>
    
      <para><emphasis>Mixin</emphasis> defines a view on the host type's subject with a different type.
        Mixin can't be combined with Predicate or Path, since the RDF identity of the mixin property is the 
        same as the host's identity.</para>    
    
    </sect2>
    
    <sect2>
    
      <title>Context</title>
      
      <para><emphasis>Context</emphasis> defines the target context of the annotated type or
      the context of the types of an annotated package.</para>
    
    </sect2>
    
    <sect2>
    
      <title>Path</title>
    
      <para><emphasis>Path</emphasis> defines a chain of predicates for read-only properties. The value accessible
      by the predicate path is bound to the property. Path can contain both direct and inverse predicates. </para>
    
    </sect2>
    
    <sect2>
    
      <title>Required</title>
    
      <para><emphasis>Required</emphasis> defines that a certain property is mandatory.</para>
      
<programlisting language="java"><![CDATA[    
@ClassMapping(ns=TEST.NS)
public class User {

    @Id
    private String id;

    @Predicate
    @Required
    private String email;
    
}
]]></programlisting>       
          
    
    </sect2>
    
<!-- 	
    <sect2>
    
      <title>Unique</title>
    
      <para><emphasis>Unique</emphasis> defines that the annotated property is unique.</para>
      
<programlisting language="java"><![CDATA[    
@ClassMapping(ns=TEST.NS)
public class User {

    @Id
    private String id;

    @Predicate(ln="user_name")
    @Unique
    private String userName;
    
}
]]></programlisting>       
    
    </sect2>
-->	
    
    </sect1>
    
    <sect1>
    
      <title>Basic RDF persistence</title>
      
      <para>The API for RDF persistence via JavaBean objects is the com.mysema.rdfbean.object.Session interface.</para>
      
      <para>To obtain a Session you need a Repository instance which acts as an abstraction layer for the actual RDF data persistence
      and a SessionFactory instance to create Session instances. See the integration guides on how to get started with RDFBean for Sesame or
      own of the included persistence providers.</para>
      
	  <sect2>
	  	
		<title>Minimal example</title>
	  
      <para>Here is a minimal setup for testing : </para>
      
      <programlisting language="java"><![CDATA[
// minimal memory based repository for RDF statement storage
Repository repository = new MiniRepository(); 
Configuration configuration = new DefaultConfiguration(User.class, Department.class, Company.class);
SessionFactoryImpl sessionFactory = new SessionFactoryImpl();
sessionFactory.setConfiguration(configuration);
sessionFactory.setRepository(repository);
sessionFactory.initialize();
]]></programlisting>      

    <para>The given Java classes could be for example the following :</para>
    
<programlisting language="java"><![CDATA[          
    @ClassMapping(ns=TEST.NS)
    public static class User {
        
        @Id
        private String id;
     
        @Predicate
        private Department department;
        
        @Predicate
        private String userName;

        public String getId() {
            return id;
        }

        public Department getDepartment() {
            return department;
        }

        public String getUserName() {
            return userName;
        }
        
        public void setDepartment(Department department){
            this.department = department;
        }
        
        public void setUserName(String userName){
            this.userName = userName;
        }

    }
    
    @ClassMapping(ns=TEST.NS)
    public static class Department {
        
        @Id
        private String id;
        
        @Predicate
        private Company company;

        public String getId() {
            return id;
        }

        public Company getCompany() {
            return company;
        }
        
        public void setCompany(Company company){
            this.company = company;
        }
        
    }
    
    @ClassMapping(ns=TEST.NS)
    public static class Company {
        
        @Id
        private String id;
        
        @Predicate
        private String companyName;

        public String getId() {
            return id;
        }
        
        public String getCompanyName(){
            return companyName;
        }
        
        public void setCompanyName(String name){
            this.companyName = name;
        }
        
    }    
]]></programlisting>          

    <para>Now you can obtain a Session instance from the SessionFactory like this :</para>
    
    <programlisting language="java"><![CDATA[
Session session = sessionFactory.openSession();    
]]></programlisting>

    <para>And the basic CRUD operations available are these :</para>
    
    <programlisting language="java"><![CDATA[
// create
User user = new User();
user.setUserName("johnsmith");
session.save(user);
assertNotNull(user.getId());

// update
Department department = new Department();
user.setDepartment(department);
session.save(user);
assertNotNull(department.getId());
session.flush();
session.clear();

// retrieve
User other = session.getById(user.getId(), User.class);
assertEquals(user.getId(), other.getId());

// delete
session.delete(user);
    
]]></programlisting>

      </sect2>
	  
	  <sect2>
	  	
		<title>RDF I/O</title>
		
		<para>
			If you want to load data from RDF/XML or Turtle files or serialize data of your repository into files you can
			use the following methods in the Repository interface.
		</para>
		
<programlisting language="java"><![CDATA[		
    /**
     * Load the contents to the Repository
     * 
     * @param format Format to be used
     * @param is input stream
     * @param context target context or null for default
     * @param replace whether to replace the contents of the target context
     */
    void load(Format format, InputStream is, @Nullable UID context, boolean replace);
    
    /**
     * Export the contents of the Repository 
     * 
     * @param format Format to be used
     * @param os target stream for output
     */
    void export(Format format, OutputStream os);		
]]></programlisting>

	<para>
		The supported formats are N3, NTRIPLES, RDFA, RDFXML, TRIG and Turtle.
	</para>		
	  	
	  </sect2>
    
    </sect1>
    
    <sect1>
    
      <title>Type-safe querying</title>      
      
      <para>RDFBean uses Querydsl to provide a type-safe object oriented querying interface on top of RDFBean domain models.
      Querydsl usage is presented in the form of examples</para>
      
      <para>Querydsl uses generated query types to enable the construction of type-sae queries.</para>
      
      <para>See the Querydsl documentation for Querydsl usage specific details.</para>
      
      <sect2>
      
         <title>Configuring Querydsl</title>
         
         <para>If you are using Maven, then the following APT configuration will create Querydsl query types into the
         folder <emphasis>target/generated-sources/java</emphasis> : </para>
         
             <programlisting language="xml"><![CDATA[
<plugin>
  <groupId>com.mysema.maven</groupId>
  <artifactId>maven-apt-plugin</artifactId>
  <version>1.0</version>
  <executions>
    <execution>
      <goals>
        <goal>process</goal>
      </goals>
      <configuration>
        <outputDirectory>target/generated-sources/java</outputDirectory>
        <processor>com.mysema.rdfbean.query.BeanAnnotationProcessor</processor>
      </configuration>
    </execution>
  </executions>
</plugin>
]]></programlisting>
      
      </sect2>
      
      <sect2>
      
      <title>Querying with Querydsl</title>
      
    <para>
      BeanQuery is the main querying interface for RDFBean. You obtain a BeanQuery instance like this 
    </para>

    <programlisting language="java"><![CDATA[
QCustomer customer = QCustomer.customer; // query variable    
// where session is a RDFBean session
BeanQuery query = session.from(customer);
]]></programlisting>

    <para>
      To retrieve the customer with the first name Bob you would construct a
      query like this :
  </para>

    <programlisting language="java"><![CDATA[
QCustomer customer = QCustomer.customer;
Customer bob = session.from(customer)
  .where(customer.firstName.eq("Bob"))
  .uniqueResult(customer);
]]></programlisting>

    <para>
      The from call defines the query source, the where part defines the
      filter and uniqueResult defines the projection and tells Querydsl
      to return a single element. Easy, right?
  </para>
  
  <para>
    To create a query with multiple sources you onbtain a BeanQuery interface like this :
  </para>

    <programlisting language="java"><![CDATA[
session.from(customer, company);    
]]></programlisting>    

   <para>
   And to use multiple filters use it like this
   </para>
   
   <programlisting language="java"><![CDATA[
session.from(customer)
    .where(customer.firstName.eq("Bob"), customer.lastName.eq("Wilson"));   
]]></programlisting>   
  
  <para>Or like this</para>
    
<programlisting language="java"><![CDATA[
session.form(customer)
    .where(customer.firstName.eq("Bob").and(customer.lastName.eq("Wilson")));
]]></programlisting>      
      
  </sect2>    
      
  <sect2>
      
  <title>General usage</title>
  
  <para>Use the the cascading methods of the BeanQuery interface like this</para>
  
  <para><emphasis>from :</emphasis> Define the query sources here.</para>
  
  <para><emphasis>where :</emphasis> Define the query filters, either in varargs form separated via commas or 
  cascaded via the and-operator.</para>
  
  <para><emphasis>orderBy :</emphasis> Define the ordering of the result as an varargs array of order expressions. 
  Use asc() and desc() on numeric, string and other comparable expression to access the OrderSpecifier instances. </para>
  
  <para><emphasis>limit, offset, restrict :</emphasis> Define the paging of the result. Limit for max results, 
  offset for skipping rows and restrict for defining both in one call.</para>
  
  </sect2>  
  
  <sect2>
  
  <title>Ordering</title>
  
  <para>The syntax for declaring ordering is </para>
  
<programlisting language="java"><![CDATA[ 
session.from(customer)
    .orderBy(customer.lastName.asc(), customer.firstName.desc())
    .list(customer);
]]></programlisting>

  </sect2>  
  
  <sect2>
    <title>Subqueries</title>
    
    <para>Here are some examples on how to use subqueries in RDFBean :</para>
	
<programlisting language="java"><![CDATA[ 
QCustomer other = new QCustomer("other");
session.from(customer)
     .where(new BeanSubQuery()
	 	.from(other).where(other.ne(customer), other.city.eq(customer.city)).notExists())
    .list(customer);
]]></programlisting>	

	<para>This query returns all the customers which don't share the city with any other customers.</para>
	
	<para>Usually it makes sense to provide a factory method for subquery creation. Here is one way to do it :</para>
	
<programlisting language="java"><![CDATA[ 
private BeanSubQuery subQuery(EntityPath<?> entity){
    return new BeanSubQuery().from(entity);
}
]]></programlisting>		

	<para>This way the query gets simplified to the following form : </para>
	
<programlisting language="java"><![CDATA[ 
QCustomer other = new QCustomer("other");
session.from(customer)
    .where(subQuery(other).where(other.ne(customer), other.city.eq(customer.city)).notExists())
    .list(customer);
]]></programlisting>		
  
  </sect2>
      
    </sect1>
    
</chapter>    